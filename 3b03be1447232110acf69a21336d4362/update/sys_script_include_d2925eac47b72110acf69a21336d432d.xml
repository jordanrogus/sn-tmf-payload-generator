<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>x_648117_tmf_mock.ItemCharacteristicUtils</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description>Utility functions for the Item Characteristic (x_648117_tmf_mock_item_characteristic) table.</description>
        <name>ItemCharacteristicUtils</name>
        <script><![CDATA[var ItemCharacteristicUtils = Class.create();
ItemCharacteristicUtils.prototype = {
    initialize: function() {
        this.utilsSI = new x_648117_tmf_mock.Utils();
    },

    /**
     * Retrieves product offering characteristics
     * 
     * @param productOffering {string} - Sys_id of the product offering to query
     * @param specification {string} - Sys_id of the specification to query
     * @return {array} - Characteristics as an array of objects in the format: [{characteristic: "charName", mandatory: false, options: ["val1","val2"]}]
     **/
    getProductOfferingCharacteristics(productOffering, specification) {
		if (productOffering === undefined || specification === undefined) {
            return [];
        }

        var characteristics = [];
        var productOfferingCharsGr = this.utilsSI.getRecords('sn_prd_pm_product_offering_characteristic', 'product_offering=' + productOffering + '^specification=' + specification);
        if (productOfferingCharsGr) {
            while (productOfferingCharsGr.next()) {
                var charFound = false;

                // Check if an object in the chars array already has the characteristic. If so, and the characteristic uses choices, add the choice to the object
                for (i = 0; i < characteristics.length; i++) {
                    if (characteristics[i].characteristic == productOfferingCharsGr.getValue('characteristic')) {
                        charFound = true;
                        if (this._checkToUpdateCharacteristicOptions(productOfferingCharsGr, characteristics[i])) {
                            characteristics[i].options.push(productOfferingCharsGr.getDisplayValue('characteristic_option'));
                        }
                    }
                }

                if (!charFound) {
                    characteristics.push(this._generateCharMapObj(productOfferingCharsGr));
                }
            }
        }
        return characteristics;
    },

    /**
     * Determines if the characteristic option needs to be updated
     * 
     * @param productOfferingCharsGr {GlideRecord object} - Product offering characteristic
     * @param characteristicArray {array} - Characteristics as an array of objects in the format: [{characteristic: "charName", mandatory: false, options: ["val1","val2"]}]
     * @return {boolean} - True or False based on the check. True denotes the characteristic option does not exist and should be added
     **/
    _checkToUpdateCharacteristicOptions(productOfferingCharsGr, characteristicObj) {
        if (productOfferingCharsGr === undefined || characteristicObj === undefined || productOfferingCharsGr.getValue('characteristic_option') == null || !characteristicObj.hasOwnProperty('options')) {
            return false;
        }

        if (characteristicObj.options.indexOf(productOfferingCharsGr.getDisplayValue('characteristic_option')) == -1) {
            return true;
        }

        return false;
    },

    /**
     * Generates an object for a characteristic
     * 
     * @param productOfferingCharsGr {GlideRecord object} - Product offering characteristic
     * @return {object} - {characteristic: "charName", mandatory: false, options: ["val1","val2"]}
     **/
    _generateCharMapObj(productOfferingCharsGr) {
		if (productOfferingCharsGr === undefined) {
            return {};
        }

        var map = {};
        map.characteristic = productOfferingCharsGr.getValue('characteristic');
        map.mandatory = productOfferingCharsGr.getValue('is_mandatory');
        if (productOfferingCharsGr.getValue('characteristic_option') != null) {
            map.options = [productOfferingCharsGr.getDisplayValue('characteristic_option')];
        }
        return map;
    },

    /**
     * Generates a record for the item characteristic
     * 
     * @param characteristicObj {GlideRecord object} - Characteristics as an array of objects in the format: [{characteristic: "charName", mandatory: false, options: ["val1","val2"]}]
	 * @param item {string} - Sys_id of the item
     * @param populateData {boolean} - User input if data should be auto-generated for all characteristics
     * @return {null} 
     **/
    generateItemCharacteristic(characteristicObj, item, populateData) {
		
		if (characteristicObj === undefined || item === undefined || populateData === undefined) {
            return null;
        }
		
        var itemCharacteristicGr = new GlideRecord('x_648117_tmf_mock_item_characteristic');
        itemCharacteristicGr.newRecord();
        itemCharacteristicGr.characteristic = characteristicObj.characteristic;
		itemCharacteristicGr.item = item;

        // Generate a characteristic value if the user asked for all to be generated or the characteristic is mandatory
        if (populateData == 1 || characteristicObj.mandatory == 1) {
			itemCharacteristicGr.characteristic_value = this._generateCharacteristicValue(characteristicObj);
		}
            
        itemCharacteristicGr.insert();
    },

	/**
     * Generates a random characteristic value 
     * 
     * @param characteristicObj {object} - A characteristic in the format: {characteristic: "charName", mandatory: false, options: ["val1","val2"]}
     * @return {string} - The characteristic value
     **/
    _generateCharacteristicValue(characteristicObj) {
		if (characteristicObj === undefined) {
            return null;
        }
		
        if (characteristicObj.hasOwnProperty('options') == true) {
            return characteristicObj.options[this.utilsSI.getRandomIntFromInterval(0, characteristicObj.options.length - 1)];
        } else {
            return this.utilsSI.generateRandomString(10);
        }
    },

    type: 'ItemCharacteristicUtils'
};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2023-06-29 21:58:17</sys_created_on>
        <sys_id>d2925eac47b72110acf69a21336d432d</sys_id>
        <sys_mod_count>25</sys_mod_count>
        <sys_name>ItemCharacteristicUtils</sys_name>
        <sys_package display_value="TMF Mock Payload Generator" source="x_648117_tmf_mock">3b03be1447232110acf69a21336d4362</sys_package>
        <sys_policy/>
        <sys_scope display_value="TMF Mock Payload Generator">3b03be1447232110acf69a21336d4362</sys_scope>
        <sys_update_name>sys_script_include_d2925eac47b72110acf69a21336d432d</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2023-06-30 18:39:27</sys_updated_on>
    </sys_script_include>
</record_update>
